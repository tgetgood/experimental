;; CPS version of the core interpreter
(ns xprl.core)
;; Note that `defn` below is the usual `(def ~name (fn ~args ~@body)).
;;
;; But `defm` is more like typical `defmacro`. It receives its arguments
;; unevaluated and may manipulate them as fexprs. Anything defined with `defm`
;; is expected to manually call `eval` on its result (unless you really know
;; that you don't want to). This is still being sorted out.

;; Essentially anything defined with `defn` should do what you expect, but
;; `defm` are reflective operations that take the entire program state and
;; transform it to a new one.
;;
;; That needs a less concise explanation

(defn eval [env form cont]
  ;; My previous idea of sneaking the return into the environment was
  ;; daft. Determining what a form means in a context should have no effect on
  ;; that context. Though of course it often does, in real life, cause us to
  ;; reevaluate our understanding of the form, the context, or both...
  (cont form))

(defn eval [env ^Symbol sym cont]
  ;; something akin to
  ;; The form pointed to by `sym` should have been evaluated before being bound
  ;; into the env.
  (cont (get-in env [:names sym])))

;; Incidental definitions will not be written in CPS
(defn reduce [f, init, coll]
  (if (empty? coll)
    init
    (reduce f (f init (first coll)) (rest coll))))

(defn transduce [xform f to from]
  ;; This isn't quite right because of the lack of mutability in the core
  ;; language. What would be a stateful transducer in clojure will here be a
  ;; stateless function that simultaneously emits values to the next transducer
  ;; and recurs (emits a new next state to itself). Details need to be worked
  ;; out.
  (let [g (xform f)]
    (g (reduce g to from))))

(defn into [to xform from]
  (transduce xform conj to from))

(defn eval [env ^Collection coll cont]
  ;; wave hands
  (cont (into (empty coll) (comp (map (partial eval env)) (map :ret)) coll)))

(defn eval [env ^List form cont]
  ;; Pass the fn and args as sexps to apply
  (apply env (first form) (rest form) cont))

;; We could probably get more efficient code gen by making then and else
;; continuations and jumping directly, but I like the elegance of this approach,
;; we'll see if it makes the cut

(defn true [env then else cont]
  (eval env then cont))

(defn false [env then else cont]
  (eval env else cont))

;; N.B.: We allow polymorphic dispatch on values as well as types. This allows
;; us to add what are effectively keywords to the language without stepping up
;; to a level inaccessible to developers using the language.
;;
;; It should be possible to compile away this indirection most of the time since
;; these literal symbols will be present in the textual source.
(defn apply [env ^(quote xprl.core/if) _ [p-form then else] cont]
  (eval env p-form (fn [pred] (pred env then else cont))))

(defn apply [env ^(quote xprl.core/let) _ [bindings body] cont]
  ;; Note the similarity to function application, but also the difference.
  ;; The computation is fully specified, so why not make a thunk here?
  (eval
   ;; Again we decontinuate when unambiguous.
   (destructuring-bind env (map first bindings) (map second bindings))
   body
   cont))

(defn apply [env ^(quote fn) _ [args body] cont]
  (cont ^Fn {:env  env
             :args args
             :body body}))

(defn apply [env ^Fn f args cont]
  ;; schedule is still to be defined in detail, but in essence we have a global
  ;; work queue with one task runner per logical core, as in any implementation
  ;; of the actor model.
  (schedule ^Thunk {:env (destructuring-bind env (:args f) args)
                    :form (:body f)
                    :cont cont}))

(defn eval [_ ^Thunk t _]
  ;; There's something special here. Thunks ignore the calling environment and
  ;; continuation and so are context free (or perhaps contextually self
  ;; contained).
  (eval (:env t) (:form t) (:cont t)))

;; I'm not sure if try/catch is a construct I want in this language. This is
;; more an exercise.
(defn apply [env ^(quote try) _ [body catch] cont]
  (let [throw ^Fn {:env env
                   :args (first catch)
                   :body (cont (second catch))}]
    (eval (bind env 'throw throw) body cont)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;; Top level hacks

;; The fact is that there are no global variables, but the idea of making the
;; developer write namespaces of code as maps to be read in is going to cause a
;; lot of friction (with me as well).
;;
;; So, `ns` and `def` effect the repl and code reader. The repl is essentially:

(defn repl [env stdin stdout]
  (let [[cursor form] (read env stdin)
        [e' ret]     (eval env form)]
    (emit {stdout ret
           recur  [e' cursor stdout]})))

;; We need apply to be able to modify that `env` value which is passed
;; recursively back to `repl` on each iteration.
;;
;; The problem is that I don't want every invocation of `eval` to have to return
;; a new environment even though the vast majority of invocations will just
;; return it unchanged. This having to thread something all the way through
;; "just in case" is a design problem I've been banging my head on (and not just
;; me, it comes up in all sorts of designs, cf. :before, :after, &c. in CLOS,
;; aspect oriented design, OO in general: smalltalk used encapsulation to hide
;; data in objects until someone wanted it, oh and don't forget monads...).
;;
;; Do I really have a new way of doing this? None of the ones I've seen really
;; do it for me, so I keep looking. If you're going to try, go all the way...

(defn apply [env ^(quote xprl.core/ns) _ [name imports] cont env-cont]
  (-> env
      (merge-imports imports)
      (assoc :current-ns name)
      env-cont))

(defn apply [env ^(quote xprl.core/def) _ [name body] cont env-cont]
  (env-cont (update env bind name (eval env body))))

(defn apply [env ^(quote xprl.core/defn) _ [name args body] cont env-cont]
  ;; Note that `backtick` needs an environment to function since it must resolve
  ;; symbols (resolution is at read time, even when the code isn't read at all).
  (eval env `(def (fn ~args ~body)) cont env-cont))

;; The fact that this is just a one-off hack for top-level evaluation makes me
;; think I'm missing something here. We could just do something like:

(defn apply [env ^(quote xprl.core/def) _ [name body] cont]
  (cont (top-level {:env (update env bind name (eval env body)) :ret name})))

;; and

(defn repl [env stdin stdout]
  (let [[cursor form] (read env stdin)
        result        (eval env form)
        [e' ret-val]  (if (top-leve? result)
                       [(:env result) (:ret result)]
                       [env result])]
    (emit {stdout ret-val
           recur  [e' cursor stdout]})))

;; But that feels like I'm missing an opportunity to see something more general.

;; When you receive a program from elsewhere, it must come with a full context
;; of interpretation (interpreter, dependencies, continuation, ... it must be a
;; fully independent organism) but what is that context of interpretation? Where
;; did *it* come from?

;; During normal execution, the environment is static. Things mean what they
;; mean and you can't change that.
;;
;; What you can do is create a new environment and evaluate *something else*
;; inside of it. This is really what locals and function calling are.

;; So defining a new name at the top level is logically the same as creating a
;; new interpreter with one more thing in the environment and running the repl
;; in that. The prompt will appear the same, but the repl you're typing into
;; will be one higher on the tower.

;; Oh boy, towers! and here I thought we'd gotten away from that.

;; So my last version of `repl` above is just the tail recursive version of "def
;; as the creation of a new interpreter". Hmm...

;; One more sticky point: `eval` itself is (or should be) defined as part of the
;; environment. More precisely, the methods of eval should all exist in the
;; environment. Is it possible to bootstrap a "universal" (I hate that word)
;; evaluator that looks up and steps into other interpreters on demand? That
;; really feels like what I'm going for here.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; There's a close relation between Smith's (3-lisp's) ↑/↓ and backtick/eval. I
;; need to dig deeper into this since it seems that Friedman and Wand really won
;; in the long term and we have arbitrary reflective depth without a tower of
;; interpreters.
;;
;; Or does it only feel that way? I have to admit I don't honestly understand
;; (have no intuition regarding) what it means to operate at a level more than
;; one interpreter above my own code.

(eval env '(+ x y)) -> ↓(+ ↓(resolve env x) ↓(resolve env y))

;; where ↓ indicates that a form is to be interpreted from one level deeper than
;; "here", that is it turn fexprs into code, the opposite ↑ is essentially
;; `quote`.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Example evaluations

(transduce (map square) + 0 (range 10))

;; I want to be able to read a list by something like:

(into '() (reduce (partial read env) stdin))

;; Of course that doesn't work, but the idea keeps smacking me.

;; The problem with `fold`, `map`, and the rest of the squiggol crowd is that
;; they all assume that the input signal is already broken down for you. `(map f
;; c)` requires that every member of `c` be of the type `f` expects.

;; But `reduce` in the sense I'm using it is different. Reduce can take an
;; unstructured sequential thing like a stream, a websocket, or a string, and
;; decide for itself where to draw the boundaries. A string tokeniser is a
;; simple example, or a streaming JSON parser.

(defn reduce [f coll]
  (when (seq coll)
    (let [[rest & vals] (f coll)]
      (emit #{(apply collect vals)
              (recur f rest)}))))

;; So reduce taks a function which breaks a chunk off of a collection and calls
;; it repeatedly until the collection is exhausted. It emits all of the chunks
;; as a stream which can then be picked up by transducers or just folded into a
;; different collection.

(fn [f out coll]
  (if (empty? coll)
    out
    (let [[cursor & vals] (f coll)]
      (recur f (fold out conj vals) cursor))))

;; Would be the equivalent, except that it presupposes what we're going to do
;; with the chunks.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; An example of multiple continuation
;;;;; (multiple value return to multiple locations concurrently)

;; I'm using cps below to make the control flow explicit

(def read-dispatch
  {\( read-list
   \[ read-vector
   \{ read-map
   \# read-indirect
   \" read-string
   \^ read-meta
   ...})

(def indirect-dispatch
  {\{ read-set
   ...})

(defn read [env stdin cont]
  (read-until env :EOS stdin cont))

(defn read-until [env until stdin cont]
  (let [c (first stdin)
        f (get read-dispatch c read-atom)]
    (if (= c until)
      (cont :EOS)
      (f env until stdin cont))))

(defn resolve [env ^string token cont]
  (cond
    (number? token)         (parse-num token cont)
    (starts-with? \: token) (read-keyword token cont)
    :else                   (read-symbol token
                                         (fn [s]
                                           ;; Free variables are a read time
                                           ;; error.  Function parameters aren't
                                           ;; considered free in this sense
                                           ;; REVIEW: What does `assert` do? We
                                           ;; don't have exceptions, errors, or
                                           ;; anything like that yet.
                                           (assert (bound? env s) cont)
                                           (cont s)))))

(defn read-atom [env until stdin cont]
  (split-at
   until stdin
   (fn [[token rest]]
     (resolve
      env token
      (fn [val]
        (cont :stdin rest :form val))))))

;; Observations:

;; 1) We call `cont`, thus poping the return stack, explicitly outside of
;; primitives. We actually do that quite a bit. I need to read Steele's argument
;; again and figure out what I'm misunderstanding.
;;
;; 2) I'm passing keyword args back to `cont` to distinguish return values. We
;; could just say (cont [rest val]), but there's a self-documenting elegance to
;; naming the things returned. It makes it clear that the function is returning
;; multiple *kinds* of things, not just multiple values of the same kind.
;;
;; There's a fundamental difference between `div` which returns a quotient and a
;; remainder, two different quantities which together define integer division,
;; and `sqrt` which always returns 2 values, both of which are equally solutions
;; to the equation x = y^2.
;;
;; I want to be able to make that distinction explicit. So here we would define

(defn div [x y cont]
  (cont :quot (quot x y) :rem (mod x y))) ; actual impl unimportant

(defn sqrt [x cont]
  (cont :return @(complex-roots x 2)))

;; The syntax @[...] is just a reader macro for `values` in multi value return.
;; We don't have `deref` so this isn't ambiguous.

;; Aside from making it easier to keep values in registers as you pass them
;; around, what is this continuation? It's not the traditional lisp functional
;; GOTO. Well it's that but more complicated.

;; `cont` above is the glue that turns a bunch of functions into a program. It's
;; the top down half of the holarchy.

;; Functions are autonomous units when viewed from within. What they do depends
;; only on their arguments. But when viewed from a higher vantage point, they
;; are subordinate, not only because a higher level process controls what
;; arguments they will get, but also what happens to the values they produce.

;; A generator is just

(fn [x cont]
  (cont :return @(lazy-seq ...)))

;; But the real question now is: how do we control where these named returns go?
;; And especially how do we do that without requiring programmers to write CPS
;; code? The latter could be as simple as "everything is `async`, and all calls
;; are `await`, and we just drop that syntax. So let's focus on the former.


(defn repl [env stdin cont]
  (read
   env stdin
   (fn [{:keys [stdin form *err*]}]
     (if *err* (cont :*err* *err*)
         (eval
          env form
          (fn [{:keys [result *err*] :as ev}]
            (if *err*
              (cont :*err* *err*)
              (cont :stdout result
                    :recur [(if (new-env? ev env) (:env ev) env) stdin]))))))))

;; But now `cont` is responsable for recursion of `repl`. A trampoline,
;; basically. Is that progress?

;; A much cleaner solution might be:

(defn repl [call-env stdin cont]
  (read
   env stdin)
  (extend cont
    (fn [{:keys [stdin form]}]
      (eval
       env form
       (extend cont
         (fn [{:keys [env result]}
              (cont :stdout result
                    :recur [(or env call-env) stdin])]))))))

;; Where `extend` adds a new method to the continuation. This new method is the
;; one that the immediate caller expects the function to return to. But `cont`
;; also has an `error` return which it inherits from above unless overridden, so
;; that `assert` can abort correctly without the intervening functions having to
;; manage it. Of course they can override to catch the error and recover.

;; At the compiler level, the last `cont` invocation would break into something
;; like:

(emit {:stdout result
       :recur [...]})

;; which in turn becomes

(schedule ^Thunk {:env (bind env 'x result) :form '(emit *stdout* (str x)) :cont halt}
          ^Thunk {:env  (bind env
                             'call-env (or env call-env)
                             'stdin stdin)
                  :form '(repl call-env stdin)
                  :cont scheduler})

;; Which sets two coroutines going concurrently, one of which prints and halts,
;; and the other loops by using the scheduler as a trampoline.

;; `(emit *stdout* x)` is redundant but included here for clarity. How the
;; "channel" (for lack of a better term) `*stdout*` is connected to the outside
;; world is beyond the control of the user program as a whole. Unix (or
;; whichever OS) decides what stdout is, and how programs interact with it. The
;; hope is that we can wrap the OS semantics closely enough so that userspace
;; programs can interact with pipes in the usual manner, but by isolating it
;; like this you can call a sub-program and *not pass it stdout* which means it
;; has no way to interact with that pipe. A program controls which syscalls are
;; available to its subprograms, thus providing (hopefully) robust
;; sandboxing. We'll see where that goes.

;; Next steps: What should the surface level syntax look like? How do you
;; manipulate the top down control pattern as you call functions? Callbacks are
;; terrible for simplicity and comprehension.
